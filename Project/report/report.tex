\documentclass{scrartcl}

\usepackage[table,xcdraw]{xcolor}
\usepackage{listings}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{float}
\usepackage{amsmath}
\usepackage[headsepline]{scrlayer-scrpage}
\usepackage{tikz}
\usepackage{siunitx}


\begin{document}

\input{title}

\pagenumbering{arabic}
\pagestyle{scrheadings}
\clearscrheadfoot

\ihead{SoRTES Project}
\cfoot{\pagemark}

\newpage

\section{The system}
The system consists of 4 tasks:
\begin{itemize}
    \item LoRaReceiver
    \item DatabaseManager
    \item LoRaSender
    \item CommandManager
\end{itemize}

There are 2 queues, the \textit{DatabaseQueue} and the \textit{LoRaSenderQueue}.
We also have a semaphore that is required for every access to EEPROM.

\subsection{LoRaReceiver}
This task receives and reads incoming beacons. Packets with a size smaller than 5 will be ignored because
we assume the message of the beacon has a length of atleast 5 characters. The system can handle packets with more characters
as long as they follow the format, that the first 4 characters are the gateway ID and the remaining characters are the time until the
next beacon transmission in seconds. Once a beacon is received, the time until the next beacon is put in the \textit{DatabaseQueue} and
the \textit{firstPackageReceived} flag is set to \textit{true} if it was false. Next the \textit{DatabaseManager} task
is resumed and the \textit{LoRaReceiver} will go to sleep for $x$ seconds, where $x$ is the time until the next beacon.
When the \textit{LoRaReceiver} processed 20 beacons, it will put the system in ultra low-power mode.

\subsection{DatabaseManager}
This task reads values from the \textit{DatabaseQueue} and runs as long as there are items available in the queue.
If the queue is empty, the task will suspend itself and only resume when the function \textit{vTaskResume()} is called in the \textit{LoRaReceiver}.
The item in the queue gets grabbed and the \textit{DatabaseManager} takes or waits for the
semaphore. We get the temperature from the temperature sensor and then we write the temperature and the data from the queue to the database.
After the write we update the address that refers to the address behind the last write in the EEPROM. We also store this value in the first
2 bytes of the EEPROM so we can resume adding to the database at the end without overwriting the old data when the arduino is restarted.
When the EEPROM is full, we reset and start writing from the first address again. After writing to the EEPROM, the semaphore is returned.
The last step is putting the temperature into the \textit{LoRaSenderQueue} and resume the \textit{LoRaSender} task.
Now we have processed one item from the \textit{DatabaseQueue}.

\newpage

\subsection{LoRaSender}
This task reads values from the \textit{LoRaSenderQueue} and runs as long as there are items available in the queue.
If the queue is empty, the task will suspend itself and only resume when the function \textit{vTaskResume()} is called in the \textit{DatabaseManager}.
This task reads the temperature value from the queue, makes a packet and sends it back to the gateway (GW).

\subsection{CommandManager}
This task reads commands from the serial port and prints output to the serial port at a rate of 9600 baud.
There are 4 commands supported (the input for these functions is just the numbers 1, 2, 3 and 4):
\begin{enumerate}
    \item Read the latest temperature value and beacon details from database and print the output to the serial port
    \item Read all temperature values and beacon details from database and print the output to the serial port
    \item Turn on ultra low-power mode
    \item Reset the database
\end{enumerate}
When the first package is received, the \textit{CommandManager} removes itself as a task and disables the usb subsystem to save power.

\section{Varying real-time constraint}
The task \textit{LoRaReceiver} will sleep for $x$ seconds where $x$ is the time in the received beacon.
When the task wakes up again, it resumes the LoRa module (because it goes into sleep mode when the system is in low-power operation mode)
and is ready again to accept beacons. $x$ is not the duration that the whole system will be in low-power operation mode.
The system only goes in low-power operation mode when all other tasks are finished.
Usually the next beacon arrives 600-1000ms after the \textit{LoRaReceiver} is ready. So it's possible to increase
the duration of sleep for the task.

\section{Synchronization}
We use a semaphore for accessing the database. Only the \textit{DatabaseManager} and the \textit{CommandManager} acquire the semaphore.
The semaphore always gets returned so a task will never get suspended before they release the semaphore.

\newpage

\section{Power consumption}
\subsection{Low-power operation mode}
When there are no tasks active, the system goes into the \textit{vApplicationIdleHook}.
Here we turn off the ADC (Analog to Digital Converter),
put the LoRa module in sleep mode and the microcontroller (MCU) in Idle mode.
This leads to a power consumption of $\sim \SI{2.90}{\milli\ampere}$.
We leave the low-power operation mode as soon as the \textit{LoRaReceiver} task gets active again.

\subsection{Ultra low-power mode}
After receiving 20 beacons or after executing the third command, the system goes into ultra low-power mode.
First we remove the task scheduler and disable the LoRa module.
Next we disable the usb subsystem (if the third command was used), turn off ADC and set all pins to output and low.
We put the MCU in power down mode and use the function \textit{power\_all\_disable()} to disable all modules.
Here we have a power consumption of $\sim \SI{814}{\micro\ampere}$.


\end{document}
